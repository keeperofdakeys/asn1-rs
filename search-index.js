var searchIndex = {};
searchIndex["asn1_cereal"] = {"doc":"","items":[[0,"serial","asn1_cereal","",null,null],[11,"asn1_tag","collections::vec","",0,{"inputs":[],"output":{"name":"tag"}}],[11,"asn1_type","","",0,{"inputs":[],"output":{"name":"type"}}],[11,"serialize_bytes","","",0,null],[11,"deserialize_bytes","","",0,{"inputs":[{"name":"e"},{"name":"i"},{"name":"option"}],"output":{"name":"result"}}],[11,"asn1_tag","collections::string","",1,{"inputs":[],"output":{"name":"tag"}}],[11,"asn1_type","","",1,{"inputs":[],"output":{"name":"type"}}],[11,"serialize_bytes","","",1,null],[11,"deserialize_bytes","","",1,{"inputs":[{"name":"e"},{"name":"i"},{"name":"option"}],"output":{"name":"result"}}],[8,"Asn1Serialize","asn1_cereal::serial","A trait that provides the plumbing for serializing ASN.1\ndata from a Rust type.",null,null],[11,"serialize","","Serialize a value into ASN.1 data as DER.",2,null],[11,"serialize_enc","","Serialize a value into ASN.1 data using a specific set of encoding rules.",2,null],[10,"serialize_bytes","","Serialise a value into ASN.1 data, without a tag (implicit tagging).",2,null],[8,"Asn1Deserialize","","A trait that provides the plumbing for deserializing ASN.1\ndata into a Rust type.",null,null],[11,"deserialize","","Deserialize ASN.1 data into a Rust value, accepting any valid BER.",3,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules.",3,{"inputs":[{"name":"e"},{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc_tag","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules. Also\nuse a specific tag, rather than reading from stream.",3,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"}],"output":{"name":"result"}}],[10,"deserialize_bytes","","Deserialise ASN.1 data without a tag into a value.",3,{"inputs":[{"name":"e"},{"name":"i"},{"name":"option"}],"output":{"name":"result"}}],[8,"Asn1Info","","A trait that provides data about the ASN.1 tag and type for a Rust type.",null,null],[10,"asn1_tag","","Get the ASN.1 tag for this Rust type.",4,{"inputs":[],"output":{"name":"tag"}}],[10,"asn1_type","","Get the ASN.1 type for this Rust type.",4,{"inputs":[],"output":{"name":"type"}}],[0,"ber","asn1_cereal","",null,null],[0,"stream","asn1_cereal::ber","A SAXParser inspired stream parser and encoder for tags in an ASN.1 streams.",null,null],[3,"StreamDecoder","asn1_cereal::ber::stream","A decoder that calls into a struct implementing the StreamDecodee trait,\nsimilar to a SAXParser",null,null],[3,"StreamEncoder","","A stream encoder that implements StreamDecodee. Using this,\na ASN.1 stream can be written using a SAXParser style interface.",null,null],[4,"ParseResult","","The result of parsing after a callback on a StreamDecodee.",null,null],[13,"Ok","","Everything went okay.",5,null],[13,"Stop","","Decoding should stop.",5,null],[13,"Skip","","Decoding should skip next element.",5,null],[13,"DecodeError","","An error occured decoding an element.",5,null],[13,"EncodeError","","An error occured encoding an element.",5,null],[13,"IO","","An IO error occured.",5,null],[8,"StreamDecodee","","This trait provides a SAXParser inspired interface for parsing ASN.1 streams.",null,null],[11,"start_element","","This function is called when an ASN.1 tag is encountered. In other\nwords, at the start of an ASN.1 element.",6,null],[11,"end_element","","This function is called when an ASN.1 element has finished decoding.\nNote that this is also called for all elements, even after a primitive()\ncall. For this reason, you may need to check the constructed flag in some\ncases.",6,null],[11,"primitive","","This function is called when a primitive element is encountered. Note that both\nstart_element and end_element are called before/after this function.",6,null],[11,"warning","","This function would be called when a recoverable decode error occurs, however\ncurrently nothing calls this.",6,{"inputs":[{"name":"decodeerror"}],"output":{"name":"parseresult"}}],[11,"error","","This function would be called when a fatal decoding error occurs, however\ncurrently nothing calls this.",6,{"inputs":[{"name":"decodeerror"}],"output":null}],[11,"new","","",7,{"inputs":[{"name":"r"},{"name":"s"}],"output":{"name":"self"}}],[11,"decode","","Decode an asn1 element.",7,null],[11,"new","","",8,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"start_element","","",8,null],[11,"end_element","","",8,null],[11,"primitive","","",8,null],[11,"from","","",5,{"inputs":[{"name":"decodeerror"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"encodeerror"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"tag","asn1_cereal","",null,null],[3,"Tag","asn1_cereal::tag","A struct containing the information from an ASN.1 tag, which represents an ASN.1 element.",null,null],[12,"class","","The class flag in the ASN.1 tag.",9,null],[12,"tagnum","","The tag number in the ASN.1 tag.",9,null],[12,"constructed","","The constructed flag in the ASN.1 tag, indicating whether this element contains another ASN.1 element.",9,null],[3,"TagLen","","A struct containing the ASN.1 tag and length of an ASN.1 element.",null,null],[12,"tag","","The tag of this ASN.1 element.",10,null],[12,"len","","The len of this ASN.1 element.",10,null],[4,"Class","","An ASN.1 Class.",null,null],[13,"Universal","","Universal class.",11,null],[13,"Application","","Application class.",11,null],[13,"ContextSpecific","","Context-specific class.",11,null],[13,"Private","","Private class.",11,null],[4,"Len","","An enum representing the length of an ASN.1 element.",null,null],[13,"Def","","A Definite length element.",12,null],[13,"Indef","","An Indefinite length element, not known before decoding.",12,null],[6,"Type","","A type for ASN.1 type names.",null,null],[6,"TagNum","","An ASN.1 tag number.",null,null],[6,"LenNum","","",null,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"eq","","",11,null],[11,"from","","",11,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"fmt","","",11,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"eq","","",9,null],[11,"ne","","",9,null],[11,"is_structured","","Returns true when this element is a SEQUENCE (OF), or SET (OF).",9,null],[11,"read_tag","","Given an iterator over a byte stream, read and return a Tag struct.",9,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_tag","","Write this ASN.1 Tag struct to the given writer.",9,null],[11,"clone","","",12,null],[11,"fmt","","",12,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"read_indef_end","","Given an iterator, read an indefinite length terminator.",12,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_indef_end","","Write an indefinite length terminator to the given writer.",12,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[11,"read_len","","Given an iterator over a byte stream, read and return the ASN.1 element length.",12,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_len","","Write this ASN.1 length to the given writer.",12,null],[11,"as_num","","A short-hand function to quickly get an Option&lt;LenNum&gt;.",12,null],[11,"from","","",12,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"from","core::option","",13,{"inputs":[{"name":"len"}],"output":{"name":"self"}}],[11,"partial_cmp","asn1_cereal::tag","",12,null],[11,"eq","","",12,null],[11,"partial_cmp","","",12,null],[11,"fmt","","",12,null],[11,"clone","","",10,null],[11,"fmt","","",10,null],[11,"eq","","",10,null],[11,"ne","","",10,null],[11,"read_taglen","","Given an iterator over a byte stream, read and return a TagLen struct.",10,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_taglen","","Write the ASN.1 representation of this TagNum struct to the given writer.",10,null],[0,"byte","asn1_cereal","",null,null],[3,"ByteReader","asn1_cereal::byte","A reader to easily read a byte from a reader, while keeping a read count.",null,null],[12,"count","","",14,null],[3,"ByteWriter","","A writer to easily write a byte to a writer, while keeping a write count.",null,null],[12,"count","","",15,null],[5,"read_byte","","Read a byte from an iterator, and translate Eof into an UnexpectedEof error.",null,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[5,"write_byte","","Write a byte to a writer, and return an error when nothing was written.",null,{"inputs":[{"name":"w"},{"name":"u8"}],"output":{"name":"result"}}],[11,"new","","Create a new ByteReader from an Iterator.",14,{"inputs":[{"name":"i"}],"output":{"name":"bytereader"}}],[11,"read","","Read a byte, and translate Eof into an UnxpectedEof error.",14,null],[11,"next","","",14,null],[11,"from","","",14,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"new","","",15,{"inputs":[{"name":"w"}],"output":{"name":"bytewriter"}}],[11,"write_byte","","Write a byte, failing if no data was written.",15,null],[11,"write","","",15,null],[11,"flush","","",15,null],[0,"err","asn1_cereal","",null,null],[4,"DecodeError","asn1_cereal::err","Errors that can occur while decoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",16,null],[13,"GreaterLen","","Child element(s) decoded to greater length than the parent&#39;s tag.",16,null],[13,"SmallerLen","","Child element(s) decoded to smaller length than the parent&#39;s tag.",16,null],[13,"PrimIndef","","Primitive value encoded with an indefinite length.",16,null],[13,"TagTypeMismatch","","Decoded tag does not match the expected tag for this type.",16,null],[13,"ExplicitTag","","An explicit tag appeared where an Implicit tag was expected.",16,null],[13,"IndefiniteLen","","Indefinite length encoding appeared when definite length encoding was\nexpected.",16,null],[13,"IndefiniteLenEnd","","Indefinite length encoding was started, but no terminator was found\nat the end.",16,null],[13,"Custom","","Custom decoding error.",16,null],[4,"EncodeError","","Errors that can occur while encoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",17,null],[11,"fmt","","",16,null],[11,"from","","",16,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",17,null],[11,"from","","",17,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"enc","asn1_cereal","",null,null],[3,"DER","asn1_cereal::enc","Distinguished Encoding Rules are a subset of BER, and provide a\ndeterministic, shortest form of encoding. These are the default\nencoding rules used when encoding ASN.1.",null,null],[3,"BER","","Basic Encoding Rules define the most basic rules that can be\nused to encode an ASN.1 tag. These are the default encoding rules\nused when decoding ASN1, as all variants are valid BER.",null,null],[3,"BERAlt","","This set of rules creates a valid BER stream, but will use\nimplicit tags where possible, and indefinite length encoding\nfor all constructed elements.",null,null],[4,"TagEnc","","An enum which determines how tags are encoded.",null,null],[13,"Explicit","","When encoding, all tags will be encoded as explicit tags.\nWhen decoding, implict or explict tags will be accepted.\nImplicit: Tags that can be encoded implicitly must",18,null],[13,"Implicit","","When encoding, constructed tags will be encoded as implicit\ntags where possible.\nWhen decoding, it&#39;s an error to use an explicit tag for\na constructed element, where an implicit tag could be\nused instead.",18,null],[4,"LenEnc","","An enum which determines how lengths are encoded.",null,null],[13,"Definite","","When encoding, all lengths are encoded using the definite form.\nWhen decoding, it&#39;s an error for lengths to be encoded in\nanything but definite form.",19,null],[13,"Indefinite","","When encoding, all lengths for constructed elements are\nencoded using the indefinite form.\nWhen decoding, definite and indefinite lengths are accepted.",19,null],[8,"Asn1EncRules","","A trait to define encoding rules to use while encoding ASN.1.",null,null],[10,"tag_rules","","Get the encoding rules for tags.",20,{"inputs":[],"output":{"name":"tagenc"}}],[10,"len_rules","","Get the encoding rules for lengths.",20,{"inputs":[],"output":{"name":"lenenc"}}],[10,"shortest_form","","Returns true when primitive elements should be encoded using\nthe shortest form. If this is true when decoding, it should\nbe an error to not use the shortest form.",20,{"inputs":[],"output":{"name":"bool"}}],[11,"eq","","",18,null],[11,"eq","","",19,null],[11,"clone","","",21,null],[11,"tag_rules","","",21,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",21,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",21,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",22,null],[11,"tag_rules","","",22,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",22,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",22,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",23,null],[11,"tag_rules","","",23,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",23,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",23,{"inputs":[],"output":{"name":"bool"}}],[14,"asn1_sequence!","asn1_cereal","This macro is a compact way of defining all three of the\nAsn1 traits - Asn1Info, Asn1Serialize and Asn1Deserialize -\nfor a rust struct, that represents an ASN.1 sequence.",null,null],[14,"asn1_sequence_info!","","This macro defines the Asn1Info trait for a rust struct. This allows the other\ntraits to get information about this type. If you need to provide a custom\nclass or tag, consider using the asn1_info! macro.",null,null],[14,"asn1_sequence_serialize!","","This macro defines the Asn1Serialize trait for a rust struct. The code generated\nwill serialize the specified fields in the order that they are given.",null,null],[14,"asn1_sequence_deserialize!","","This macro defines the Asn1Deserialize trait for a rust struct. The code generated\nwill deserialize the specified fields in the order that they are given.",null,null],[14,"asn1_newtype!","","This macro is a compact way of defining both of the\nAsn1 serialization traits - Asn1Serialize and Asn1Deserialize\n- for a rust newtype, that represents an ASN.1 type definition.",null,null],[14,"asn1_newtype_serialize!","","This macro defines the Asn1Serialize trait for a rust newtype.",null,null],[14,"asn1_newtype_deserialize!","","This macro defines the Asn1Serialize trait for a rust newtype.",null,null],[14,"asn1_choice!","","",null,null],[14,"asn1_choice_serialize!","","",null,null],[14,"asn1_choice_deserialize!","","",null,null],[14,"asn1_info!","","This macro defines the Asn1Info trait for a rust type.",null,null],[11,"serialize","asn1_cereal::serial","Serialize a value into ASN.1 data as DER.",2,null],[11,"serialize_enc","","Serialize a value into ASN.1 data using a specific set of encoding rules.",2,null],[11,"deserialize","","Deserialize ASN.1 data into a Rust value, accepting any valid BER.",3,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules.",3,{"inputs":[{"name":"e"},{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc_tag","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules. Also\nuse a specific tag, rather than reading from stream.",3,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"}],"output":{"name":"result"}}]],"paths":[[3,"Vec"],[3,"String"],[8,"Asn1Serialize"],[8,"Asn1Deserialize"],[8,"Asn1Info"],[4,"ParseResult"],[8,"StreamDecodee"],[3,"StreamDecoder"],[3,"StreamEncoder"],[3,"Tag"],[3,"TagLen"],[4,"Class"],[4,"Len"],[4,"Option"],[3,"ByteReader"],[3,"ByteWriter"],[4,"DecodeError"],[4,"EncodeError"],[4,"TagEnc"],[4,"LenEnc"],[8,"Asn1EncRules"],[3,"DER"],[3,"BER"],[3,"BERAlt"]]};
initSearch(searchIndex);
