var searchIndex = {};
searchIndex["asn1_cereal"] = {"doc":"# asn1-cereal\nA collection of encoders and decoders for BER, DER and ASN.1.","items":[[0,"tag","asn1_cereal","Encoding and decoding of tag and length bytes for BER.",null,null],[3,"Tag","asn1_cereal::tag","A struct containing the information from an ASN.1 tag, which represents an ASN.1 element.",null,null],[12,"class","","The class flag in the ASN.1 tag.",0,null],[12,"tagnum","","The tag number in the ASN.1 tag.",0,null],[12,"constructed","","The constructed flag in the ASN.1 tag, indicating whether this element contains another ASN.1 element.",0,null],[4,"Class","","An ASN.1 Class.",null,null],[13,"Universal","","Universal class.",1,null],[13,"Application","","Application class.",1,null],[13,"ContextSpecific","","Context-specific class.",1,null],[13,"Private","","Private class.",1,null],[4,"Len","","An enum representing the length of an ASN.1 element.",null,null],[13,"Def","","A Definite length element.",2,null],[13,"Indef","","An Indefinite length element, not known before decoding.",2,null],[5,"read_taglen","","Given an iterator over a byte stream, read and return a `TagLen` struct.",null,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[5,"write_taglen","","Write the ASN.1 representation of this `TagNum` struct to the given writer.",null,{"inputs":[{"name":"tag"},{"name":"len"},{"name":"w"}],"output":{"name":"result"}}],[6,"Type","","A type for ASN.1 type names.",null,null],[6,"TagNum","","An ASN.1 tag number.",null,null],[6,"LenNum","","",null,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"from","","",1,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"is_structured","","Returns true when this element is a SEQUENCE (OF), or SET (OF).",0,null],[11,"read_tag","","Given an iterator over a byte stream, read and return a Tag struct.",0,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_tag","","Write this ASN.1 Tag struct to the given writer.",0,null],[11,"fmt","","",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"read_indef_end","","Given an iterator, read an indefinite length terminator.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_indef_end","","Write an indefinite length terminator to the given writer.",2,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[11,"read_len","","Given an iterator over a byte stream, read and return the ASN.1 element length.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_len","","Write this ASN.1 length to the given writer.",2,null],[11,"as_num","","A short-hand function to quickly get an Option&lt;LenNum&gt;.",2,null],[11,"from","","",2,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"partial_cmp","","",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null],[11,"fmt","","",2,null],[0,"err","asn1_cereal","Encoding and Decoding errors that this crate can produce.",null,null],[3,"DecodeError2","asn1_cereal::err","An error that occurs while decoding an ASN.1 element.",null,null],[4,"DecodeError","","Errors that can occur while decoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",3,null],[13,"GreaterLen","","Child element(s) decoded to greater length than the parent&#39;s tag.",3,null],[13,"SmallerLen","","Child element(s) decoded to smaller length than the parent&#39;s tag.",3,null],[13,"PrimIndef","","Primitive value encoded with an indefinite length.",3,null],[13,"TagTypeMismatch","","Decoded tag does not match the expected tag for this type.",3,null],[13,"ExplicitTag","","An explicit tag appeared where an Implicit tag was expected.",3,null],[13,"IndefiniteLen","","Indefinite length encoding appeared when definite length encoding was\nexpected.",3,null],[13,"IndefiniteLenEnd","","Indefinite length encoding was started, but no terminator was found\nat the end.",3,null],[13,"Custom","","Custom decoding error.",3,null],[4,"EncodeError","","Errors that can occur while encoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",4,null],[13,"Custom","","Custom encoding error.",4,null],[11,"fmt","","",3,null],[11,"from","","",3,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",4,null],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"byte","asn1_cereal","Constructs for reading and writing bytes used by this crate.",null,null],[3,"ByteReader","asn1_cereal::byte","A reader to easily read a byte from a reader, while keeping a read count.",null,null],[12,"count","","",5,null],[3,"ByteWriter","","A writer to easily write a byte to a writer, while keeping a write count.",null,null],[12,"count","","",6,null],[5,"read_byte","","Read a byte from an iterator, and translate Eof into an `UnexpectedEof` error.",null,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[5,"write_byte","","Write a byte to a writer, and return an error when nothing was written.",null,{"inputs":[{"name":"w"},{"name":"u8"}],"output":{"name":"result"}}],[11,"new","","Create a new ByteReader from an Iterator.",5,{"inputs":[{"name":"i"}],"output":{"name":"bytereader"}}],[11,"read","","Read a byte, and translate Eof into an UnxpectedEof error.",5,null],[11,"next","","",5,null],[11,"from","","",5,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"new","","",6,{"inputs":[{"name":"w"}],"output":{"name":"bytewriter"}}],[11,"write_byte","","Write a byte, failing if no data was written.",6,null],[11,"write","","",6,null],[11,"flush","","",6,null],[0,"info","asn1_cereal","",null,null],[8,"Asn1Info","asn1_cereal::info","Provides ASN.1 information about a Rust type, including the BER tag and ASN.1 type.",null,null],[10,"asn1_tag","","Get the ASN.1 tag (if defined) for this Rust type. Some types don&#39;t have a tag, eg. CHOICE.",7,{"inputs":[],"output":{"name":"option"}}],[10,"asn1_type","","Get the ASN.1 type for this Rust type.",7,{"inputs":[],"output":{"name":"type"}}],[0,"ber","asn1_cereal","Tools that can be used to parse BER streams.",null,null],[0,"stream","asn1_cereal::ber","A `SAXParser` inspired stream parser and encoder for ber streams.",null,null],[3,"StreamDecoder","asn1_cereal::ber::stream","A decoder that calls into a struct implementing the `StreamDecodee` trait,\nsimilar to a `SAXParser`.",null,null],[3,"StreamEncoder","","A stream encoder that implements `StreamDecodee`. Using this,\na ASN.1 stream can be written using a `SAXParser` style interface.",null,null],[4,"ParseResult","","The result of parsing after a callback on a `StreamDecodee`.",null,null],[13,"Ok","","Everything went okay.",8,null],[13,"Stop","","Decoding should stop.",8,null],[13,"Skip","","Decoding should skip next element.",8,null],[13,"DecodeError","","An error occured decoding an element.",8,null],[13,"EncodeError","","An error occured encoding an element.",8,null],[13,"IO","","An IO error occured.",8,null],[8,"StreamDecodee","","This trait provides a `SAXParser` inspired interface for parsing ASN.1 streams.",null,null],[11,"start_element","","This function is called when an ASN.1 tag is encountered. In other\nwords, at the start of an ASN.1 element.",9,null],[11,"end_element","","This function is called when an ASN.1 element has finished decoding.\nNote that this is also called for all elements, even after a primitive()\ncall. For this reason, you may need to check the constructed flag in some\ncases.",9,null],[11,"primitive","","This function is called when a primitive element is encountered. Note that both\nstart_element and end_element are called before/after this function.",9,null],[11,"warning","","This function would be called when a recoverable decode error occurs, however\ncurrently nothing calls this.",9,{"inputs":[{"name":"decodeerror"}],"output":{"name":"parseresult"}}],[11,"error","","This function would be called when a fatal decoding error occurs, however\ncurrently nothing calls this.",9,{"inputs":[{"name":"decodeerror"}],"output":null}],[11,"new","","",10,{"inputs":[{"name":"r"},{"name":"s"}],"output":{"name":"self"}}],[11,"decode","","Decode an asn1 element.",10,null],[11,"new","","",11,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"start_element","","",11,null],[11,"end_element","","",11,null],[11,"primitive","","",11,null],[11,"from","","",8,{"inputs":[{"name":"decodeerror"}],"output":{"name":"self"}}],[11,"from","","",8,{"inputs":[{"name":"encodeerror"}],"output":{"name":"self"}}],[11,"from","","",8,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"enc","asn1_cereal::ber","Encoding rules to use for BER.",null,null],[3,"DER","asn1_cereal::ber::enc","Distinguished Encoding Rules are a subset of BER, and provide a\ndeterministic, shortest form of encoding. These are the default\nencoding rules used when encoding ASN.1.",null,null],[3,"BER","","Basic Encoding Rules define the most basic rules that can be\nused to encode an ASN.1 tag. These are the default encoding rules\nused when decoding ASN1, as all variants are valid BER.",null,null],[3,"BERAlt","","This set of rules creates a valid BER stream, but will use\nimplicit tags where possible, and indefinite length encoding\nfor all constructed elements.",null,null],[4,"TagEnc","","An enum which determines how tags are encoded.",null,null],[13,"Explicit","","When encoding, all tags will be encoded as explicit tags.\nWhen decoding, implict or explict tags will be accepted.\nImplicit: Tags that can be encoded implicitly must",12,null],[13,"Implicit","","When encoding, constructed tags will be encoded as implicit\ntags where possible.\nWhen decoding, it&#39;s an error to use an explicit tag for\na constructed element, where an implicit tag could be\nused instead.",12,null],[4,"LenEnc","","An enum which determines how lengths are encoded.",null,null],[13,"Definite","","When encoding, all lengths are encoded using the definite form.\nWhen decoding, it&#39;s an error for lengths to be encoded in\nanything but definite form.",13,null],[13,"Indefinite","","When encoding, all lengths for constructed elements are\nencoded using the indefinite form.\nWhen decoding, definite and indefinite lengths are accepted.",13,null],[8,"BerEncRules","","A trait to define encoding rules to use while encoding ASN.1.",null,null],[10,"tag_rules","","Get the encoding rules for tags.",14,{"inputs":[],"output":{"name":"tagenc"}}],[10,"len_rules","","Get the encoding rules for lengths.",14,{"inputs":[],"output":{"name":"lenenc"}}],[10,"shortest_form","","Returns true when primitive elements should be encoded using\nthe shortest form. If this is true when decoding, it should\nbe an error to not use the shortest form.",14,{"inputs":[],"output":{"name":"bool"}}],[11,"eq","","",12,null],[11,"eq","","",13,null],[11,"clone","","",15,null],[11,"tag_rules","","",15,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",15,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",15,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",16,null],[11,"tag_rules","","",16,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",16,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",16,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",17,null],[11,"tag_rules","","",17,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",17,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",17,{"inputs":[],"output":{"name":"bool"}}],[0,"serial","asn1_cereal::ber","Traits for serializing and deserializing rust types from/to ASN.1.",null,null],[0,"traits","asn1_cereal::ber::serial","The base traits that are used for serializing and deserializing rust types.",null,null],[8,"BerSerialize","asn1_cereal::ber::serial::traits","Provides the methods required to serialize this Rust type into an ASN.1 stream.",null,null],[11,"serialize","","Serialize a value into ASN.1 data as DER.",18,null],[11,"serialize_enc","","Serialize a value into ASN.1 data using a specific set of encoding rules.",18,null],[11,"_serialize_enc","","An empty method that is called first by `serialize_enc` to allow custom\nhandling, without losing normal serialization behaviour.",18,null],[10,"serialize_value","","Serialise a value into ASN.1 data, without a tag (implicit tagging).",18,null],[8,"BerDeserialize","","Provides the methods required to deserialize this Rust type from an ASN.1 stream.",null,null],[11,"deserialize","","Deserialize ASN.1 data into a Rust value, accepting any valid BER.",19,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules.",19,{"inputs":[{"name":"e"},{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_with_tag","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules, and\nalso providing the decoded tag and length.",19,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"},{"name":"len"}],"output":{"name":"result"}}],[11,"_deserialize_with_tag","","An empty method that is called first by `deserialize_with_tag` to allow\ncustom handling, without losing normal deserialization behaviour.",19,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"},{"name":"len"}],"output":{"name":"option"}}],[11,"deserialize_value","","Deserialize an ASN.1 value from a BER stream, after having the tag and length\ndecoded.",19,{"inputs":[{"name":"e"},{"name":"i"},{"name":"len"}],"output":{"name":"result"}}],[0,"prim","asn1_cereal::ber::serial","A collection of primitive wrappers for ASN.1, where a direct Rust equivalent may not exist.",null,null],[3,"OctetString","asn1_cereal::ber::serial::prim","A Rust wrapper for OCTET STRING.",null,null],[11,"asn1_tag","","",20,{"inputs":[],"output":{"name":"option"}}],[11,"asn1_type","","",20,{"inputs":[],"output":{"name":"type"}}],[11,"serialize_value","","",20,null],[11,"deserialize_value","","",20,{"inputs":[{"name":"e"},{"name":"i"},{"name":"len"}],"output":{"name":"result"}}],[0,"int","asn1_cereal::ber::serial","Implementation of the serialization traits for Rust integers.",null,null],[0,"str","","Implementation of the serialization traits for String.",null,null],[0,"bool","","Implementation of the serialization traits for Rust booleans.",null,null],[0,"alias","","Macros to generate the implementation of the serialization traits for Rust\nnewtypes (tuple structs). This can be used to represent ASN.1 type\nassignments, or wrap Rust types, to provide distinct types.\n```\n#[macro_use] extern crate asn1_cereal; fn main() {\n  struct A(u64);",null,null],[0,"choice","","Macros to generate the implementation of the serialization traits for Rust\nenums, as ASN.1 choice.",null,null],[0,"seq","","Macros to generate the implementation of the serialization traits for Rust\nstructs, as an ASN.1 SEQUENCE. You can technically use this for a SET, but it\nstill assumes the elements are in order.",null,null],[0,"seq_of","","Macros to generate the implementation of the serialization traits for Rust\niterators, as ASN.1 sequence of.",null,null],[14,"asn1_info!","asn1_cereal","This macro defines the Asn1Info trait for a rust type.",null,null],[14,"asn1_spec_tag!","","This macro parses an ASN.1 tag specification, and returns the appropriate Tag.",null,null],[14,"ber_alias!","","Generate the implemention of an ASN.1 alias for a Rust type.",null,null],[14,"ber_alias_info!","","Generate the Asn1Info implemention of an ASN.1 alias for a Rust type.",null,null],[14,"ber_alias_serialize!","","This macro defines the BerSerialize trait for an ASN.1 type alias.",null,null],[14,"ber_alias_deserialize!","","This macro defines the BerSerialize trait for an ASN.1 type alias.",null,null],[14,"ber_choice!","","Generate the Asn1Info implemention for an ASN.1 Choice type, represented\nby a Rust enum.",null,null],[14,"ber_choice_serialize!","","Generate the BerSerialize implemention for an ASN.1 Choice type, represented\nby a Rust enum.",null,null],[14,"ber_choice_deserialize!","","Generate the BerDeserialize implemention for an ASN.1 Choice type, represented\nby a Rust enum.",null,null],[14,"ber_sequence!","","This macro is a compact way of defining all three of the\nAsn1 traits - Asn1Info, BerSerialize and BerDeserialize -\nfor a rust struct, that represents an ASN.1 sequence.",null,null],[14,"asn1_sequence_info!","","This macro defines the Asn1Info trait for a rust struct. This allows the other\ntraits to get information about this type. If you need to provide a custom\nclass or tag, consider using the asn1_info! macro.",null,null],[14,"ber_sequence_serialize!","","This macro defines the BerSerialize trait for a rust struct. The code generated\nwill serialize the specified fields in the order that they are given.",null,null],[14,"ber_sequence_deserialize!","","This macro defines the BerDeserialize trait for a rust struct. The code generated\nwill deserialize the specified fields in the order that they are given.",null,null],[14,"ber_sequence_of!","","Generate a SEQUENCE OF implementation for an iterator type. `asn1_info!` must\nbe called manually.",null,null],[14,"ber_sequence_of_serialize!","","Implement BerSerialize for a type, by iterating over each element, and\ncalling serialize_enc on each element.",null,null],[14,"ber_sequence_of_deserialize!","","Implement BerDeserialize for a type, by collecting the elements from an iterator\nbuilt by calling deserialize_enc on the stream continually.",null,null]],"paths":[[3,"Tag"],[4,"Class"],[4,"Len"],[4,"DecodeError"],[4,"EncodeError"],[3,"ByteReader"],[3,"ByteWriter"],[8,"Asn1Info"],[4,"ParseResult"],[8,"StreamDecodee"],[3,"StreamDecoder"],[3,"StreamEncoder"],[4,"TagEnc"],[4,"LenEnc"],[8,"BerEncRules"],[3,"DER"],[3,"BER"],[3,"BERAlt"],[8,"BerSerialize"],[8,"BerDeserialize"],[3,"OctetString"]]};
searchIndex["log"] = {"doc":"A lightweight logging facade.","items":[[3,"LogRecord","log","The &quot;payload&quot; of a log message.",null,null],[3,"LogMetadata","","Metadata about a log message.",null,null],[3,"LogLocation","","The location of a log message.",null,null],[3,"MaxLogLevelFilter","","A token providing read and write access to the global maximum log level\nfilter.",null,null],[3,"SetLoggerError","","The type returned by `set_logger` if `set_logger` has already been called.",null,null],[3,"ShutdownLoggerError","","The type returned by `shutdown_logger_raw` if `shutdown_logger_raw` has\nalready been called or if `set_logger_raw` has not been called yet.",null,null],[4,"LogLevel","","An enum representing the available verbosity levels of the logging framework",null,null],[13,"Error","","The &quot;error&quot; level.",0,null],[13,"Warn","","The &quot;warn&quot; level.",0,null],[13,"Info","","The &quot;info&quot; level.",0,null],[13,"Debug","","The &quot;debug&quot; level.",0,null],[13,"Trace","","The &quot;trace&quot; level.",0,null],[4,"LogLevelFilter","","An enum representing the available verbosity level filters of the logging\nframework.",null,null],[13,"Off","","A level lower than all log levels.",1,null],[13,"Error","","Corresponds to the `Error` log level.",1,null],[13,"Warn","","Corresponds to the `Warn` log level.",1,null],[13,"Info","","Corresponds to the `Info` log level.",1,null],[13,"Debug","","Corresponds to the `Debug` log level.",1,null],[13,"Trace","","Corresponds to the `Trace` log level.",1,null],[5,"max_log_level","","Returns the current maximum log level.",null,{"inputs":[],"output":{"name":"loglevelfilter"}}],[5,"set_logger","","Sets the global logger.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"set_logger_raw","","Sets the global logger from a raw pointer.",null,{"inputs":[{"name":"m"}],"output":{"name":"result"}}],[5,"shutdown_logger","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[5,"shutdown_logger_raw","","Shuts down the global logger.",null,{"inputs":[],"output":{"name":"result"}}],[8,"Log","","A trait encapsulating the operations required of a logger",null,null],[10,"enabled","","Determines if a log message with the specified metadata would be\nlogged.",2,null],[10,"log","","Logs the `LogRecord`.",2,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"eq","","",0,null],[11,"partial_cmp","","",0,null],[11,"partial_cmp","","",0,null],[11,"cmp","","",0,null],[11,"from_str","","",0,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",0,null],[11,"max","","Returns the most verbose logging level.",0,{"inputs":[],"output":{"name":"loglevel"}}],[11,"to_log_level_filter","","Converts the `LogLevel` to the equivalent `LogLevelFilter`.",0,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"eq","","",1,null],[11,"eq","","",1,null],[11,"partial_cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"cmp","","",1,null],[11,"from_str","","",1,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[11,"fmt","","",1,null],[11,"max","","Returns the most verbose logging level filter.",1,{"inputs":[],"output":{"name":"loglevelfilter"}}],[11,"to_log_level","","Converts `self` to the equivalent `LogLevel`.",1,null],[11,"args","","The message body.",3,null],[11,"metadata","","Metadata about the log directive.",3,null],[11,"location","","The location of the log directive.",3,null],[11,"level","","The verbosity level of the message.",3,null],[11,"target","","The name of the target of the directive.",3,null],[11,"level","","The verbosity level of the message.",4,null],[11,"target","","The name of the target of the directive.",4,null],[11,"fmt","","",5,null],[11,"clone","","",5,null],[11,"module_path","","The module path of the message.",5,null],[11,"file","","The source file containing the message.",5,null],[11,"line","","The line containing the message.",5,null],[11,"fmt","","",6,null],[11,"get","","Gets the current maximum log level filter.",6,null],[11,"set","","Sets the maximum log level.",6,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"description","","",7,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"description","","",8,null],[14,"log!","","The standard logging macro.",null,null],[14,"error!","","Logs a message at the error level.",null,null],[14,"warn!","","Logs a message at the warn level.",null,null],[14,"info!","","Logs a message at the info level.",null,null],[14,"debug!","","Logs a message at the debug level.",null,null],[14,"trace!","","Logs a message at the trace level.",null,null],[14,"log_enabled!","","Determines if a message logged at the specified level in that module will\nbe logged.",null,null]],"paths":[[4,"LogLevel"],[4,"LogLevelFilter"],[8,"Log"],[3,"LogRecord"],[3,"LogMetadata"],[3,"LogLocation"],[3,"MaxLogLevelFilter"],[3,"SetLoggerError"],[3,"ShutdownLoggerError"]]};
initSearch(searchIndex);
