var searchIndex = {};
searchIndex["asn1_cereal"] = {"doc":"# asn1-cereal\nA collection of encoders and decoders for BER, DER and ASN.1.","items":[[0,"tag","asn1_cereal","Encoding and decoding of tag and length bytes for BER.",null,null],[3,"Tag","asn1_cereal::tag","A struct containing the information from an ASN.1 tag, which represents an ASN.1 element.",null,null],[12,"class","","The class flag in the ASN.1 tag.",0,null],[12,"tagnum","","The tag number in the ASN.1 tag.",0,null],[12,"constructed","","The constructed flag in the ASN.1 tag, indicating whether this element contains another ASN.1 element.",0,null],[4,"Class","","An ASN.1 Class.",null,null],[13,"Universal","","Universal class.",1,null],[13,"Application","","Application class.",1,null],[13,"ContextSpecific","","Context-specific class.",1,null],[13,"Private","","Private class.",1,null],[4,"Len","","An enum representing the length of an ASN.1 element.",null,null],[13,"Def","","A Definite length element.",2,null],[13,"Indef","","An Indefinite length element, not known before decoding.",2,null],[5,"read_taglen","","Given an iterator over a byte stream, read and return a `TagLen` struct.",null,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[5,"write_taglen","","Write the ASN.1 representation of this `TagNum` struct to the given writer.",null,{"inputs":[{"name":"tag"},{"name":"len"},{"name":"w"}],"output":{"name":"result"}}],[6,"Type","","A type for ASN.1 type names.",null,null],[6,"TagNum","","An ASN.1 tag number.",null,null],[6,"LenNum","","",null,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"eq","","",1,null],[11,"from","","",1,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[11,"fmt","","",1,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"is_structured","","Returns true when this element is a SEQUENCE (OF), or SET (OF).",0,null],[11,"read_tag","","Given an iterator over a byte stream, read and return a Tag struct.",0,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_tag","","Write this ASN.1 Tag struct to the given writer.",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"read_indef_end","","Given an iterator, read an indefinite length terminator.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_indef_end","","Write an indefinite length terminator to the given writer.",2,{"inputs":[{"name":"w"}],"output":{"name":"result"}}],[11,"read_len","","Given an iterator over a byte stream, read and return the ASN.1 element length.",2,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"write_len","","Write this ASN.1 length to the given writer.",2,null],[11,"as_num","","A short-hand function to quickly get an Option&lt;LenNum&gt;.",2,null],[11,"from","","",2,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"from","core::option","",3,{"inputs":[{"name":"len"}],"output":{"name":"self"}}],[11,"partial_cmp","asn1_cereal::tag","",2,null],[11,"eq","","",2,null],[11,"partial_cmp","","",2,null],[11,"fmt","","",2,null],[0,"err","asn1_cereal","Encoding and Decoding errors that this crate can produce.",null,null],[4,"DecodeError","asn1_cereal::err","Errors that can occur while decoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",4,null],[13,"GreaterLen","","Child element(s) decoded to greater length than the parent&#39;s tag.",4,null],[13,"SmallerLen","","Child element(s) decoded to smaller length than the parent&#39;s tag.",4,null],[13,"PrimIndef","","Primitive value encoded with an indefinite length.",4,null],[13,"TagTypeMismatch","","Decoded tag does not match the expected tag for this type.",4,null],[13,"ExplicitTag","","An explicit tag appeared where an Implicit tag was expected.",4,null],[13,"IndefiniteLen","","Indefinite length encoding appeared when definite length encoding was\nexpected.",4,null],[13,"IndefiniteLenEnd","","Indefinite length encoding was started, but no terminator was found\nat the end.",4,null],[13,"Custom","","Custom decoding error.",4,null],[4,"EncodeError","","Errors that can occur while encoding an ASN.1 element.",null,null],[13,"IO","","Generic IO Error.",5,null],[11,"fmt","","",4,null],[11,"from","","",4,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[11,"fmt","","",5,null],[11,"from","","",5,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"byte","asn1_cereal","Constructs for reading and writing bytes used by this crate.",null,null],[3,"ByteReader","asn1_cereal::byte","A reader to easily read a byte from a reader, while keeping a read count.",null,null],[12,"count","","",6,null],[3,"ByteWriter","","A writer to easily write a byte to a writer, while keeping a write count.",null,null],[12,"count","","",7,null],[5,"read_byte","","Read a byte from an iterator, and translate Eof into an `UnexpectedEof` error.",null,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[5,"write_byte","","Write a byte to a writer, and return an error when nothing was written.",null,{"inputs":[{"name":"w"},{"name":"u8"}],"output":{"name":"result"}}],[11,"new","","Create a new ByteReader from an Iterator.",6,{"inputs":[{"name":"i"}],"output":{"name":"bytereader"}}],[11,"read","","Read a byte, and translate Eof into an UnxpectedEof error.",6,null],[11,"next","","",6,null],[11,"from","","",6,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"new","","",7,{"inputs":[{"name":"w"}],"output":{"name":"bytewriter"}}],[11,"write_byte","","Write a byte, failing if no data was written.",7,null],[11,"write","","",7,null],[11,"flush","","",7,null],[0,"info","asn1_cereal","",null,null],[8,"Asn1Info","asn1_cereal::info","Provides ASN.1 information about a Rust type, including the BER tag and ASN.1 type.",null,null],[10,"asn1_tag","","Get the ASN.1 tag for this Rust type.",8,{"inputs":[],"output":{"name":"tag"}}],[10,"asn1_type","","Get the ASN.1 type for this Rust type.",8,{"inputs":[],"output":{"name":"type"}}],[0,"ber","asn1_cereal","Tools that can be used to parse BER streams.",null,null],[0,"stream","asn1_cereal::ber","A `SAXParser` inspired stream parser and encoder for ber streams.",null,null],[3,"StreamDecoder","asn1_cereal::ber::stream","A decoder that calls into a struct implementing the `StreamDecodee` trait,\nsimilar to a `SAXParser`.",null,null],[3,"StreamEncoder","","A stream encoder that implements `StreamDecodee`. Using this,\na ASN.1 stream can be written using a `SAXParser` style interface.",null,null],[4,"ParseResult","","The result of parsing after a callback on a `StreamDecodee`.",null,null],[13,"Ok","","Everything went okay.",9,null],[13,"Stop","","Decoding should stop.",9,null],[13,"Skip","","Decoding should skip next element.",9,null],[13,"DecodeError","","An error occured decoding an element.",9,null],[13,"EncodeError","","An error occured encoding an element.",9,null],[13,"IO","","An IO error occured.",9,null],[8,"StreamDecodee","","This trait provides a `SAXParser` inspired interface for parsing ASN.1 streams.",null,null],[11,"start_element","","This function is called when an ASN.1 tag is encountered. In other\nwords, at the start of an ASN.1 element.",10,null],[11,"end_element","","This function is called when an ASN.1 element has finished decoding.\nNote that this is also called for all elements, even after a primitive()\ncall. For this reason, you may need to check the constructed flag in some\ncases.",10,null],[11,"primitive","","This function is called when a primitive element is encountered. Note that both\nstart_element and end_element are called before/after this function.",10,null],[11,"warning","","This function would be called when a recoverable decode error occurs, however\ncurrently nothing calls this.",10,{"inputs":[{"name":"decodeerror"}],"output":{"name":"parseresult"}}],[11,"error","","This function would be called when a fatal decoding error occurs, however\ncurrently nothing calls this.",10,{"inputs":[{"name":"decodeerror"}],"output":null}],[11,"new","","",11,{"inputs":[{"name":"r"},{"name":"s"}],"output":{"name":"self"}}],[11,"decode","","Decode an asn1 element.",11,null],[11,"new","","",12,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"start_element","","",12,null],[11,"end_element","","",12,null],[11,"primitive","","",12,null],[11,"from","","",9,{"inputs":[{"name":"decodeerror"}],"output":{"name":"self"}}],[11,"from","","",9,{"inputs":[{"name":"encodeerror"}],"output":{"name":"self"}}],[11,"from","","",9,{"inputs":[{"name":"error"}],"output":{"name":"self"}}],[0,"enc","asn1_cereal::ber","Encoding rules to use for BER.",null,null],[3,"DER","asn1_cereal::ber::enc","Distinguished Encoding Rules are a subset of BER, and provide a\ndeterministic, shortest form of encoding. These are the default\nencoding rules used when encoding ASN.1.",null,null],[3,"BER","","Basic Encoding Rules define the most basic rules that can be\nused to encode an ASN.1 tag. These are the default encoding rules\nused when decoding ASN1, as all variants are valid BER.",null,null],[3,"BERAlt","","This set of rules creates a valid BER stream, but will use\nimplicit tags where possible, and indefinite length encoding\nfor all constructed elements.",null,null],[4,"TagEnc","","An enum which determines how tags are encoded.",null,null],[13,"Explicit","","When encoding, all tags will be encoded as explicit tags.\nWhen decoding, implict or explict tags will be accepted.\nImplicit: Tags that can be encoded implicitly must",13,null],[13,"Implicit","","When encoding, constructed tags will be encoded as implicit\ntags where possible.\nWhen decoding, it&#39;s an error to use an explicit tag for\na constructed element, where an implicit tag could be\nused instead.",13,null],[4,"LenEnc","","An enum which determines how lengths are encoded.",null,null],[13,"Definite","","When encoding, all lengths are encoded using the definite form.\nWhen decoding, it&#39;s an error for lengths to be encoded in\nanything but definite form.",14,null],[13,"Indefinite","","When encoding, all lengths for constructed elements are\nencoded using the indefinite form.\nWhen decoding, definite and indefinite lengths are accepted.",14,null],[8,"BerEncRules","","A trait to define encoding rules to use while encoding ASN.1.",null,null],[10,"tag_rules","","Get the encoding rules for tags.",15,{"inputs":[],"output":{"name":"tagenc"}}],[10,"len_rules","","Get the encoding rules for lengths.",15,{"inputs":[],"output":{"name":"lenenc"}}],[10,"shortest_form","","Returns true when primitive elements should be encoded using\nthe shortest form. If this is true when decoding, it should\nbe an error to not use the shortest form.",15,{"inputs":[],"output":{"name":"bool"}}],[11,"eq","","",13,null],[11,"eq","","",14,null],[11,"clone","","",16,null],[11,"tag_rules","","",16,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",16,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",16,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",17,null],[11,"tag_rules","","",17,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",17,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",17,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",18,null],[11,"tag_rules","","",18,{"inputs":[],"output":{"name":"tagenc"}}],[11,"len_rules","","",18,{"inputs":[],"output":{"name":"lenenc"}}],[11,"shortest_form","","",18,{"inputs":[],"output":{"name":"bool"}}],[0,"serial","asn1_cereal::ber","Traits for serializing and deserializing rust types from/to ASN.1.",null,null],[0,"traits","asn1_cereal::ber::serial","",null,null],[8,"BerSerialize","asn1_cereal::ber::serial::traits","Provides the methods required to serialize this Rust type into an ASN.1 stream.",null,null],[11,"serialize","","Serialize a value into ASN.1 data as DER.",19,null],[11,"serialize_enc","","Serialize a value into ASN.1 data using a specific set of encoding rules.",19,null],[10,"serialize_value","","Serialise a value into ASN.1 data, without a tag (implicit tagging).",19,null],[8,"BerDeserialize","","Provides the methods required to deserialize this Rust type from an ASN.1 stream.",null,null],[11,"deserialize","","Deserialize ASN.1 data into a Rust value, accepting any valid BER.",20,{"inputs":[{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_enc","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules.",20,{"inputs":[{"name":"e"},{"name":"i"}],"output":{"name":"result"}}],[11,"deserialize_with_tag","","Deserialize ASN.1 data into a Rust value, using a specific set of encoding rules, and\nalso providing the decoded tag and length.",20,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"},{"name":"len"}],"output":{"name":"result"}}],[11,"_deserialize_with_tag","","",20,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"},{"name":"len"}],"output":{"name":"option"}}],[11,"deserialize_value","","Deserialize an ASN.1 value from a BER stream, after having the tag and length\ndecoded.",20,{"inputs":[{"name":"e"},{"name":"i"},{"name":"len"}],"output":{"name":"result"}}],[0,"int","asn1_cereal::ber::serial","Implementation of the serialization traits for Rust integers.",null,null],[0,"str","","Implementation of the serialization traits for Rust strings.",null,null],[11,"asn1_tag","collections::string","",21,{"inputs":[],"output":{"name":"tag"}}],[11,"asn1_type","","",21,{"inputs":[],"output":{"name":"type"}}],[11,"serialize_value","","",21,null],[11,"deserialize_value","","",21,{"inputs":[{"name":"e"},{"name":"i"},{"name":"len"}],"output":{"name":"result"}}],[0,"assign","asn1_cereal::ber::serial","Macros to generate the implementation of the serialization traits for Rust\nnewtypes, as ASN.1 type assignments.",null,null],[0,"choice","","Macros to generate the implementation of the serialization traits for Rust\nenums, as ASN.1 choice.",null,null],[0,"seq","","Macros to generate the implementation of the serialization traits for Rust\nstructs, as ASN.1 sequences.",null,null],[0,"seq_of","","Macros to generate the implementation of the serialization traits for Rust\niterators, as ASN.1 sequence of.",null,null],[11,"asn1_tag","collections::vec","",22,{"inputs":[],"output":{"name":"tag"}}],[11,"asn1_type","","",22,{"inputs":[],"output":{"name":"type"}}],[11,"serialize_value","","",22,null],[11,"deserialize_with_tag","","",22,{"inputs":[{"name":"e"},{"name":"i"},{"name":"tag"},{"name":"len"}],"output":{"name":"result"}}],[14,"asn1_info!","asn1_cereal","This macro defines the Asn1Info trait for a rust type.",null,null],[14,"ber_newtype!","","This macro is a compact way of defining both of the\nAsn1 serialization traits - BerSerialize and BerDeserialize\n- for a rust newtype, that represents an ASN.1 type definition.",null,null],[14,"ber_newtype_serialize!","","This macro defines the BerSerialize trait for a rust newtype.",null,null],[14,"ber_newtype_deserialize!","","This macro defines the BerSerialize trait for a rust newtype.",null,null],[14,"ber_choice!","","",null,null],[14,"ber_choice_serialize!","","",null,null],[14,"ber_choice_deserialize!","","",null,null],[14,"ber_sequence!","","This macro is a compact way of defining all three of the\nAsn1 traits - Asn1Info, BerSerialize and BerDeserialize -\nfor a rust struct, that represents an ASN.1 sequence.",null,null],[14,"asn1_sequence_info!","","This macro defines the Asn1Info trait for a rust struct. This allows the other\ntraits to get information about this type. If you need to provide a custom\nclass or tag, consider using the asn1_info! macro.",null,null],[14,"ber_sequence_serialize!","","This macro defines the BerSerialize trait for a rust struct. The code generated\nwill serialize the specified fields in the order that they are given.",null,null],[14,"ber_sequence_deserialize!","","This macro defines the BerDeserialize trait for a rust struct. The code generated\nwill deserialize the specified fields in the order that they are given.",null,null],[14,"ber_sequence_of!","","",null,null],[14,"ber_sequence_of_serialize!","","",null,null],[14,"ber_sequence_of_deserialize!","","",null,null]],"paths":[[3,"Tag"],[4,"Class"],[4,"Len"],[4,"Option"],[4,"DecodeError"],[4,"EncodeError"],[3,"ByteReader"],[3,"ByteWriter"],[8,"Asn1Info"],[4,"ParseResult"],[8,"StreamDecodee"],[3,"StreamDecoder"],[3,"StreamEncoder"],[4,"TagEnc"],[4,"LenEnc"],[8,"BerEncRules"],[3,"DER"],[3,"BER"],[3,"BERAlt"],[8,"BerSerialize"],[8,"BerDeserialize"],[3,"String"],[3,"Vec"]]};
initSearch(searchIndex);
